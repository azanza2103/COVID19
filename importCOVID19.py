# Used to read the data file
import pandas as pd

import random

# Used in the definition of the model and its initial condition
import numpy as np
from scipy import integrate
from scipy.stats import lognorm

# Used for plots other than those generated by the parameter estimation module
import matplotlib.pyplot as plt
#%matplotlib inline

# Solving partial diferential equations
import PDEparams as pde

# Working with files
import os as osfiles

# Parallel computing
import multiprocessing as mp

from IPython.display import display, HTML

# For statistical plots
import seaborn as sns
#plt.rcParams['xtick.labelsize'] = 12
#plt.rcParams['ytick.labelsize'] = 12
#plt.rcParams['font.size'] = 20
#plt.rcParams['font.family'] = 'serif'
#plt.rcParams['text.usetex'] = True
sns.set_palette("muted")

#sns.set_palette(["#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2","#D55E00", "#CC79A7"])
#ncolours = len(plt.rcParams['axes.prop_cycle'])
#colours = [list(plt.rcParams['axes.prop_cycle'])[i]['color'] for i in range(ncolours)]

class COVID19:
    def __init__(self,model=None,fname=None,pars=None,bounds=None):
        self.bounds = bounds
        self.maxInfo = None
        self.randParVals = None
        self.fE0 = 10
        self.info = None
        self.startq = 16 # Quarantine start at March 14
        self.tauLinear = False
        self.tauStart = 10000
        self.modelAvail = {'SIR' : self.iniSRI, 'SEIR' : self.iniSEIR, 'SEIRfull' : self.iniSEIRfull, 'SEIRq' : self.iniSEIRq, 
                           'SEIRqt' : self.iniSEIRqt, 'SEIRbeta' : self.iniSEIRbeta, 'SEIRfullV01' : self.iniSEIRfullV01, 
                           'SEIRrand' : self.iniSEIRrand, 'SEIReta' : self.iniSEIReta,
                           'SEIRetaq' : self.iniSEIRetaq, 'SEIRetadelta' : self.iniSEIRetadelta, 
                           'SEIRweek' : self.iniSEIRweek, 'SEIRfullCOS' : self.iniSEIRfullCOS }
        self.tauInt = False
        self.fullFname = None
        self.fitData = []
        self.fitDataID = None
        self.dataMark = ''
        self.setModel(model,pars)
        self.readData(fname)
        self.actStatData = pd.DataFrame()
        self.delta = 1/10 # Avegrage hospitalition days = 10
        self.eta = 1/4 # Average days without symptoms = 4
        self.epsilon = 0.2 # 20% of the infected population shows no severe or critical symptoms
        self.q = 1
        self.states = [ "TOT", "GR0", "GR1", "GR2", "CMX", "MEX", "JAL", "PUE", "NLE", "COA", 
                        "YUC", "TAB", "ROO", "GUA", "AGU", "BCN", "SIN", "SLP", "QUE", "VER", 
                        "MIC", "OAX", "HID", "SON", "BCS", "GRO", "CHP", "CHH", "TAM", "MOR", 
                        "NAY", "DUR", "ZAC", "CAM", "TLA", "COL" ]
        
    def percentage(self,x,start,end,cosPars=None):
        dayS,perS = start
        if x<=dayS :
            return perS
        dayE,perE = end
        if x>=dayE :
            return perE
        slope = (perE-perS)/(dayE-dayS)
        intercept = perS - slope*dayS
        add = 0 if cosPars is None else cosPars[0]*np.cos((x-dayS)/cosPars[1])
        return slope*x + intercept + add

    def getpercentage(self,x):
        per = self.percentage(x,self.parsC[0],self.parsC[1],self.parsC[2])
        return per
    
    def getqtauCOS(self,x):
        per = self.percentage(x,self.parsC[0],self.parsC[1],self.parsC[2])
        return (100-per)/per

    def getepsilonCOS(self,x):
        per = self.percentage(x,self.parsEp[0],self.parsEp[1],self.parsEp[2])
        per = 0 if (per<0) else per
        return per/100

    def getbetaCOS(self,x,betain):
        beta = self.percentage(x,self.parsEp[0],self.parsEp[1],self.parsEp[2])
        beta = 0 if (beta<0) else beta
        beta = betain if (beta > betain*1.2) else beta
        eta = beta/self.R0func()
        return beta,eta

    def getfbetaCOS(self,x,betain):
        return self.percentage(x,self.parsEp[0],self.parsEp[1],self.parsEp[2])/betain
    
    # This function computes the five time derivative equations of the SEIR model with eta free
    def SEIRfullmodelCOS(self, z, t, beta, tau, q, delta, eta, epsilon):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        f = self.getqtauCOS(t)
        #epsilon = self.getepsilonCOS(t)
        beta,tmp = self.getbetaCOS(t,beta)
        tau = q*f
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    def setCOSpars(self,pars=None):
        if pars is None:
            self.qtauSpeed = 20
            self.parsC = [(1000,60),(1000,60),(0,1)]
            self.parsEp = [(1000,20),(1000,20),(0,1)]
        else:
            self.qtauSpeed = pars[0]
            self.parsC = pars[1]
            self.parsEp = pars[2]
    
    # pars = [qtauSpeed,[(dayS,perS),(dayE,perE),(amplitude,period)],[(dayS,perS),(dayE,perE)]    
    def iniSEIRfullCOS(self,pars=None):
        self.setCOSpars(pars)
        self.modelDesc = 'SEIRfullCOS'
        self.iniC = 0.0 
        self.model = self.SEIRfullmodelCOS;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,1), (0,1), (0,1), (0,1), (0,1), (0,1)] if self.bounds is None else self.bounds
        self.R0func = self.SEIRfull_R0
        self.R0funcStat = self.SEIRfull_R0_stat
        self.R0colLabel = 'beta/eta'
        self.colIDs = ['id', 'beta', 'tau', 'q', 'delta', 'eta', 'epsilon', 'beta/eta', 'error']
        self.pars  = [r'$\beta$', r'$\tau$', r'$q$', r'$\delta$', r'$\eta$', r'$\epsilon$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\tau\right>$'    ,  7 : r'$\tau_{Min}$'    ,  8 : r'$\tau_{Max}$',
                           9 : r'$\left<q\right>$'       , 10 : r'$q_{Min}$'       , 11 : r'$q_{Max}$',
                          12 : r'$\left<\delta\right>$'  , 13 : r'$\delta_{Min}$'  , 14 : r'$\delta_{Max}$',
                          15 : r'$\left<\eta\right>$'    , 16 : r'$\eta_{Min}$'    , 17 : r'$\eta_{Max}$',
                          18 : r'$\left<\epsilon\right>$', 19 : r'$\epsilon_{Min}$', 20 : r'$\epsilon_{Max}$' }
        
    # This function computes the three time derivative equations of the SRI model
    def SRImodel(self, z, t, beta, gamma):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta and gamma are the parameters of the model
        '''
        S, I, R = z
        return [-beta/self.initial_S()*S*I, 
                beta/self.initial_S()*S*I - gamma*I, 
                gamma*I]    
    
    # This function computes the five time derivative equations of the SEIR model
    def SEIRmodel(self, z, t, beta, tau, q):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        delta = self.delta
        eta = self.eta
        epsilon = self.epsilon
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    # This function computes the five time derivative equations of the SEIR model
    def SEIRbetamodel(self, z, t, beta):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        delta = self.delta
        eta = self.eta
        epsilon = self.epsilon
        q = 0.2#self.getValq(t)
        tau = q*2/3 # This is to get the 60% of susceptibles into quarantine
        #print(t,beta,tau,q,epsilon,eta,delta)
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    # This function computes the five time derivative equations of the SEIR model
    def SEIRqtmodel(self, z, t, beta, q):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        delta = self.delta
        eta = self.eta
        epsilon = self.epsilon
        q = self.getValq01(t,q)
        tau = q*2/3 # This is to get the 60% of susceptibles into quarantine
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    def getValq01(self,t,q):
        print('q')
        if (t>self.startq):
            return 1
        return q
    
    def getValq(self,t):
        print('q')
        if (t>self.startq):
            return 1
        return 0.1

    # This function computes the five time derivative equations of the SEIR model
    def SEIRqmodel(self, z, t, beta, q):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        delta = self.delta
        eta = self.eta
        epsilon = self.epsilon
        tau = q*self.tauOVq # 2/3 for 60%
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    # This function computes the five time derivative equations of the SEIR model
    def SEIRetamodel(self, z, t, beta, eta):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        delta = self.delta
        epsilon = self.epsilon
        q = self.q
        tau = q*self.tauOVq # 2/3 for 60%
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    # This function computes the five time derivative equations of the SEIR model
    def SEIRetaqmodel(self, z, t, beta, eta, q):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        delta = self.delta
        epsilon = self.epsilon
        tau = q*self.tauOVq # 2/3 for 60%
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    # This function computes the five time derivative equations of the SEIR model
    def SEIRetadeltamodel(self, z, t, beta, eta, delta):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        epsilon = self.epsilon
        q = self.q
        tau = q*self.tauOVq # 2/3 for 60%
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    
    
    def getTau(self,t,tau,q):
        if (t<=self.tauStart):
            return [tau,q]
        if (self.tauLinear and (t<=(self.tauStart+self.tauDeltad))):
            valTau = (self.tauStep-tau)/self.tauDeltad*(t-self.tauStart)+tau
            return [valTau,valTau*2/23]
        return [self.tauStep,self.tauStep*2/23]

    # The order variable sets the sequence of the quarantine lifting with a factor indicating the steps to create
    # The strategy variable sets if no strategy is used -1, 3x4 -> 0, 4x3 -> 1
    def buildScenario(self,startBreak,order,strategy=-1):
        # This a list with the index of the 1rst of each month starting from Febrary 28
        months = [95,125,156,187,217,248,278,309,340]
        months = [ startBreak + self.nmonths*30*n for n in range(9) ]
        perDict = {'kids' : 21.7, 'thirdAge' : 11.3}
        perDict['work'] = 60 - (perDict['kids']+perDict['thirdAge'])
        percentage = 60; month = 0
        # First stage of all scenarios is with 60% of population in quarantine
        res = [[0,60,(100-percentage)/percentage,-1]]
        for stage in order:
            for step in range(stage[1]):
                percentage -= perDict[stage[0]]/stage[1]
                f = (100-percentage)/percentage
                res.append([months[month],percentage,f,strategy ])#if stage[0]!='kids' else -1])
                month += 1
        return res    
    
    def getqtau(self,day,scheme=0,strategy=-1):
    #def getqtau(day,scheme=0,strategy=-1):
        scenariosLst = [[['kids',1]], [['kids',1],['work',2]], [['kids',1],['work',3]], [['kids',1],['work',4]], [['work',2],['kids',1]],
                        [['work',3],['kids',1]], [['work',4],['kids',1]]]
        scenario = self.buildScenario(self.breakDay,scenariosLst[scheme],strategy)
        qtauSpeed = self.qtauSpeed #20
        breakDay = scenario[1][0]; pos = len(scenario)-1
        for indx in range(len(scenario)-1):
            if (day>=scenario[indx][0]) and (day<scenario[indx+1][0]):
                pos = indx
                break
        f = scenario[pos][2]
        qtauSpeed = self.parVals[2] if (pos==0) else self.qtauSpeed #20
        if (pos==0):
            return [self.parVals[2],self.parVals[1],scenario[pos][1]]
            #return [qtauSpeed,qtauSpeed*f,scenario[pos][1]]
        if ((scenario[pos][3]!=-1) and (day+(7-breakDay%7))%7 >= (3+scenario[pos][3])):
            # IN quarantine
            f = scenario[pos-1][2]
            return [qtauSpeed,qtauSpeed*f,scenario[pos-1][1]]
        return [qtauSpeed/f,qtauSpeed,scenario[pos][1]]

    # This function computes the five time derivative equations of the SEIR model with eta free
    def SEIRfullmodelV01(self, z, t, beta, tau, q, delta, eta, epsilon):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        res = self.getqtau(t,self.scheme,self.strategy)
        q = res[0]; tau = res[1]
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    
        
    # This function computes the five time derivative equations of the SEIR model with eta free
    def SEIRfullmodel(self, z, t, beta, tau, q, delta, eta, epsilon):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        if (self.tauInt):
            res = self.getTau(t,tau,q)
            tau = res[0]; q = res[1]
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    # This function computes the five time derivative equations of the SEIR model with eta free
    def SEIRweekmodel(self, z, t, beta, q, delta, eta):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        tau = q*self.tauOVq
        epsilon = self.epsilon
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    # This function computes the five time derivative equations of the SEIR model with eta free
    def SEIRrandmodel(self, z, t, beta, tau, q, delta, eta):
        '''
        - The input z corresponds to the current state of the system, z = [S, I, R, C, E ]. Since the input is in 1D, no pre-processing is needed.
        - t is the current time.
        - beta, tau, q, delta are the parameters of the while eta and epsilon are fixed
        '''
        S, I, R, C, E = z
        epsilon = 0.2
        return [-beta*E*S/self.initial_S() + tau*C - q*S, 
                epsilon*eta*E - delta*I,
                (1-epsilon)*eta*E + delta*I,
                q*S - tau*C, 
                beta*E*S/self.initial_S() - eta*E ]    

    # Initialization functions for all the possible variables
    def initial_S(self):
        #return np.log(self.ini[0])
        #return self.ini[0]
        if (self.modelDesc=='SIR'):
            return self.ini[0]
        return (1-self.iniC)*self.ini[0]
    
    def initial_C(self):
        #return 0*np.log(self.ini[0])
        #return 0
        return self.iniC*self.ini[0]

    def initial_E(self):
        #return np.log(self.ini[1])
        # 1 of 10 infected individuals shows no critical or severe symptoms
        return self.fE0*self.ini[1]
    
    def initial_I(self):
        #return np.log(self.ini[1])
        return self.ini[1]
    
    def initial_R(self):
        return 0

    def SRI_R0(self):
        # Computing beta/gamma
        return self.parVals[0]/self.parVals[1]
    
    def SRI_R0_stat(self,pars):
        # Computing beta/gamma
        return pars[0]/pars[1]

    def iniSRI(self,pars=None):
        self.modelDesc = 'SIR'
        self.model = self.SRImodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R ]
        self.nvars = 3
        self.bounds = [(0,1), (0,1)] if self.bounds is None else self.bounds
        self.R0func = self.SRI_R0
        self.R0funcStat = self.SRI_R0_stat
        self.R0colLabel = 'beta/gamma'
        self.colIDs = ['id','beta','gamma','beta/gamma','error']
        self.pars  = [r'$\beta$', r'$\gamma$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\gamma\right>$'  ,  7 : r'$\gamma_{Min}$'  ,  8 : r'$\gamma_{Max}$', 
                           9 : r'$\left<error\right>$'   , 10 : r'$error_{Min}$'   , 11 : r'$error_{Max}$' }

    def SEIR_R0(self):
        return self.parVals[0]/self.eta

    def SEIR_R0_stat(self,pars):
        # Computing beta/eta
        return pars[0]/self.eta
    
    def iniSEIR(self,pars=None):
        self.modelDesc = 'SEIR'
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRmodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,1), (0,1), (0,1)]  if self.bounds is None else self.bounds
        self.R0func = self.SEIR_R0
        self.R0funcStat = self.SEIR_R0_stat
        self.R0colLabel = 'beta/eta'
        self.eta = 1/4 # Average days without symptoms = 4
        self.delta = 1/10 # Avegrage hospitalition days = 10
        self.epsilon = 0.2 # 20% of the infected population shows no severe or critical symptoms
        self.colIDs = ['id','beta','tau', 'q', 'beta/eta','error']
        self.pars  = [ r'$\beta$', r'$\tau$', r'$q$' ]
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\tau\right>$'    ,  7 : r'$\tau_{Min}$'    ,  8 : r'$\tau_{Max}$',
                           9 : r'$\left<q\right>$'       , 10 : r'$q_{Min}$'       , 11 : r'$q_{Max}$', 
                          12 : r'$\left<error\right>$'   , 13 : r'$error_{Min}$'   , 14 : r'$error_{Max}$' }
        
    def SEIRq_R0(self):
        return self.parVals[0]/self.eta

    def SEIRq_R0_stat(self,pars):
        # Computing beta/eta
        return pars[0]/self.eta

    def SEIReta_R0(self):
        return self.parVals[0]/self.parVals[1]

    def SEIReta_R0_stat(self,pars):
        # Computing beta/eta
        return pars[0]/pars[1]
    
    
    def iniSEIRq(self,pars=None):
        self.modelDesc = 'SEIRq'
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRqmodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,2), (0,2)]  if self.bounds is None else self.bounds
        self.R0func = self.SEIRq_R0
        self.R0funcStat = self.SEIRq_R0_stat
        self.R0colLabel = 'beta/eta'
        self.q = 1 # Setting a quarantine speed
        self.eta = 1/4 # Average days without symptoms = 4
        self.delta = 1/10 # Avegrage hospitalition days = 10
        self.epsilon = 0.2 # 20% of the infected population shows no severe or critical symptoms
        self.tauOVq = 2/3
        self.colIDs = ['id','beta','q', 'beta/eta','error']
        self.pars  = [ r'$\beta$', r'$q$' ]
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<q\right>$'       ,  7 : r'$q_{Min}$'       ,  8 : r'$q_{Max}$',
                           9 : r'$\left<error\right>$'   , 10 : r'$error_{Min}$'   , 11 : r'$error_{Max}$' }

    def iniSEIRqt(self,pars=None):
        self.modelDesc = 'SEIRqt'
        self.fracTau = 2/3 if (pars is None) else pars[0]
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRqtmodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,1), (0,1)]  if self.bounds is None else self.bounds
        self.R0func = self.SEIRq_R0
        self.R0funcStat = self.SEIRq_R0_stat
        self.R0colLabel = 'beta/eta'
        self.q = 1 # Setting a quarantine speed
        self.eta = 1/4 # Average days without symptoms = 4
        self.delta = 1/10 # Avegrage hospitalition days = 10
        self.epsilon = 0.2 # 20% of the infected population shows no severe or critical symptoms
        self.colIDs = ['id','beta','q', 'beta/eta','error']
        self.pars  = [ r'$\beta$', r'$q$' ]
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<q\right>$'       ,  7 : r'$q_{Min}$'       ,  8 : r'$q_{Max}$',
                           9 : r'$\left<error\right>$'   , 10 : r'$error_{Min}$'   , 11 : r'$error_{Max}$' }

    def iniSEIRbeta(self,pars=None):
        self.modelDesc = 'SEIRbeta'
        self.startq = 16 if (pars is None) else pars[0] # Quarantine start at March 14
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRbetamodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,1)] if self.bounds is None else self.bounds
        self.R0func = self.SEIRq_R0
        self.R0funcStat = self.SEIRq_R0_stat
        self.R0colLabel = 'beta/eta'
        self.eta = 1/4 # Average days without symptoms = 4
        self.delta = 1/10 # Avegrage hospitalition days = 10
        self.epsilon = 0.2 # 20% of the infected population shows no severe or critical symptoms
        self.colIDs = ['id','beta', 'beta/eta','error']
        self.pars  = [ r'$\beta$' ]
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<error\right>$'   ,  7 : r'$error_{Min}$'   ,  8 : r'$error_{Max}$' }
        
    def SEIRfull_R0(self):
        return self.parVals[0]/self.parVals[4]

    def SEIRfull_R0_stat(self,pars):
        # Computing beta/eta
        return pars[0]/pars[4]

    def iniSEIRfull(self,pars=None):
        self.modelDesc = 'SEIRfull'
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRfullmodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,10), (0,10), (0,10), (0,10), (0,10), (0,10)]  if self.bounds is None else self.bounds
        self.R0func = self.SEIRfull_R0
        self.R0funcStat = self.SEIRfull_R0_stat
        self.R0colLabel = 'beta/eta'
        self.colIDs = ['id', 'beta', 'tau', 'q', 'delta', 'eta', 'epsilon', 'beta/eta', 'error']
        self.pars  = [r'$\beta$', r'$\tau$', r'$q$', r'$\delta$', r'$\eta$', r'$\epsilon$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\tau\right>$'    ,  7 : r'$\tau_{Min}$'    ,  8 : r'$\tau_{Max}$',
                           9 : r'$\left<q\right>$'       , 10 : r'$q_{Min}$'       , 11 : r'$q_{Max}$',
                          12 : r'$\left<\delta\right>$'  , 13 : r'$\delta_{Min}$'  , 14 : r'$\delta_{Max}$',
                          15 : r'$\left<\eta\right>$'    , 16 : r'$\eta_{Min}$'    , 17 : r'$\eta_{Max}$',
                          18 : r'$\left<\epsilon\right>$', 19 : r'$\epsilon_{Min}$', 20 : r'$\epsilon_{Max}$' }

    def SEIRweek_R0(self):
        return self.parVals[0]/self.parVals[3]

    def SEIRweek_R0_stat(self,pars):
        # Computing beta/eta
        return pars[0]/pars[3]

    def iniSEIRweek(self,pars=None):
        self.modelDesc = 'SEIRweek'
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRweekmodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,10), (0,10), (0,10), (0,10)]  if self.bounds is None else self.bounds
        self.R0func = self.SEIRweek_R0
        self.R0funcStat = self.SEIRweek_R0_stat
        self.tauOVq = 2/3
        self.fE0 = 10
        self.epsilon = 0.2
        self.R0colLabel = 'beta/eta'
        self.colIDs = ['id', 'beta', 'q', 'delta', 'eta', 'beta/eta', 'error']
        self.pars  = [r'$\beta$', r'$q$', r'$\delta$', r'$\eta$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<q\right>$'       ,  7 : r'$q_{Min}$'       ,  8 : r'$q_{Max}$',
                           9 : r'$\left<\delta\right>$'  , 10 : r'$\delta_{Min}$'  , 11 : r'$\delta_{Max}$',
                          12 : r'$\left<\eta\right>$'    , 13 : r'$\eta_{Min}$'    , 14 : r'$\eta_{Max}$' }
        
        
    def iniSEIReta(self,pars=None):
        self.modelDesc = 'SEIReta'
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRetamodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,10), (0,10)]  if self.bounds is None else self.bounds
        self.R0func = self.SEIReta_R0
        self.R0funcStat = self.SEIReta_R0_stat
        self.q = 1 # Setting a quarantine speed
        self.eta = 1/4 # Average days without symptoms = 4
        self.delta = 1/10 # Avegrage hospitalition days = 10
        self.epsilon = 0.2 # 20% of the infected population shows no severe or critical symptoms
        self.tauOVq = 2/3
        self.R0colLabel = 'beta/eta'
        self.colIDs = ['id', 'beta', 'eta', 'beta/eta', 'error']
        self.pars  = [r'$\beta$', r'$\eta$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\eta\right>$'    ,  7 : r'$\eta_{Min}$'    ,  8 : r'$\eta_{Max}$',
                           9 : r'$\left<error\right>$'   , 10 : r'$error_{Min}$'   , 11 : r'$error_{Max}$' }

    def iniSEIRetadelta(self,pars=None):
        self.modelDesc = 'SEIRetadelta'
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRetadeltamodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,3), (0,3),(0,3)]  if self.bounds is None else self.bounds
        self.R0func = self.SEIReta_R0
        self.R0funcStat = self.SEIReta_R0_stat
        self.q = 1 # Setting a quarantine speed
        self.eta = 1/4 # Average days without symptoms = 4
        self.delta = 1/10 # Avegrage hospitalition days = 10
        self.epsilon = 0.2 # 20% of the infected population shows no severe or critical symptoms
        self.tauOVq = 2/3
        self.R0colLabel = 'beta/eta'
        self.colIDs = ['id', 'beta', 'eta', 'delta', 'beta/eta', 'error']
        self.pars  = [r'$\beta$', r'$\eta$', r'$\delta$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\eta\right>$'    ,  7 : r'$\eta_{Min}$'    ,  8 : r'$\eta_{Max}$',
                           9 : r'$\left<\delta\right>$'  , 10 : r'$\delta_{Min}$'  , 11 : r'$\delta_{Max}$',
                          12 : r'$\left<error\right>$'   , 13 : r'$error_{Min}$'   , 14 : r'$error_{Max}$' }

    def iniSEIRetaq(self,pars=None):
        self.modelDesc = 'SEIRetaq'
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRetaqmodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,3), (0,3), (0,3)]  if self.bounds is None else self.bounds
        self.R0func = self.SEIReta_R0
        self.R0funcStat = self.SEIReta_R0_stat
        self.q = 1 # Setting a quarantine speed
        self.eta = 1/4 # Average days without symptoms = 4
        self.delta = 1/10 # Avegrage hospitalition days = 10
        self.epsilon = 0.2 # 20% of the infected population shows no severe or critical symptoms
        self.tauOVq = 2/3
        self.R0colLabel = 'beta/eta'
        self.colIDs = ['id', 'beta', 'eta', 'q', 'beta/eta', 'error']
        self.pars  = [r'$\beta$', r'$\eta$', r'$q$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\eta\right>$'    ,  7 : r'$\eta_{Min}$'    ,  8 : r'$\eta_{Max}$',
                           9 : r'$\left<q\right>$'       , 10 : r'$q_{Min}$'       , 11 : r'$q_{Max}$',
                          12 : r'$\left<error\right>$'   , 13 : r'$error_{Min}$'   , 14 : r'$error_{Max}$' }
        
    def iniSEIRrand(self,pars=None):
        self.modelDesc = 'SEIRrand'
        self.iniC = 0.0 if (self.iniC is None) else self.iniC
        self.model = self.SEIRrandmodel;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,1), (0,1), (0,1), (0,1), (0,1)] if self.bounds is None else self.bounds
        self.R0func = self.SEIRfull_R0
        self.R0funcStat = self.SEIRfull_R0_stat
        self.R0colLabel = 'beta/eta'
        self.colIDs = ['id', 'beta', 'tau', 'q', 'delta', 'eta', 'beta/eta', 'error']
        self.pars  = [r'$\beta$', r'$\tau$', r'$q$', r'$\delta$', r'$\eta$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\tau\right>$'    ,  7 : r'$\tau_{Min}$'    ,  8 : r'$\tau_{Max}$',
                           9 : r'$\left<q\right>$'       , 10 : r'$q_{Min}$'       , 11 : r'$q_{Max}$',
                          12 : r'$\left<\delta\right>$'  , 13 : r'$\delta_{Min}$'  , 14 : r'$\delta_{Max}$',
                          15 : r'$\left<\eta\right>$'    , 16 : r'$\eta_{Min}$'    , 17 : r'$\eta_{Max}$'}

    def iniSEIRfullV01(self,pars=None):
        self.scheme = 0 if (pars is None) else pars[0] # % of quarantine lifting
        self.qtauSpeed = 20 if (pars is None) else pars[1] # High speed for q and tau
        self.breakDay = 95 if (pars is None) else pars[2] # This corresponds to June 1rst
        #self.qtauFactor = 2/3 if (pars is None) else pars[3] # t/q factor for 60% of population in quarantine
        self.strategy = -1 if (pars is None) else pars[3] # -1:None, 0:3x4 scheme, 1:4x3 scheme
        self.nmonths = 1 if (pars is None) else pars[4] # Number of months to extend a given quarantine strategy
        self.modelDesc = 'SEIRfullV01'
        self.iniC = 0.0 
        self.model = self.SEIRfullmodelV01;
        self.start = [ self.initial_S, self.initial_I, self.initial_R, self.initial_C, self.initial_E ]
        self.nvars = 5
        self.bounds = [(0,1), (0,1), (0,1), (0,1), (0,1), (0,1)] if self.bounds is None else self.bounds
        self.R0func = self.SEIRfull_R0
        self.R0funcStat = self.SEIRfull_R0_stat
        self.R0colLabel = 'beta/eta'
        self.colIDs = ['id', 'beta', 'tau', 'q', 'delta', 'eta', 'epsilon', 'beta/eta', 'error']
        self.pars  = [r'$\beta$', r'$\tau$', r'$q$', r'$\delta$', r'$\eta$', r'$\epsilon$']
        self.DescColID = { 0 : r'$\left<R0\right>$'      ,  1 : r'$R0_{Min}$'      ,  2 : r'$R0_{Max}$',
                           3 : r'$\left<\beta\right>$'   ,  4 : r'$\beta_{Min}$'   ,  5 : r'$\beta_{Max}$',
                           6 : r'$\left<\tau\right>$'    ,  7 : r'$\tau_{Min}$'    ,  8 : r'$\tau_{Max}$',
                           9 : r'$\left<q\right>$'       , 10 : r'$q_{Min}$'       , 11 : r'$q_{Max}$',
                          12 : r'$\left<\delta\right>$'  , 13 : r'$\delta_{Min}$'  , 14 : r'$\delta_{Max}$',
                          15 : r'$\left<\eta\right>$'    , 16 : r'$\eta_{Min}$'    , 17 : r'$\eta_{Max}$',
                          18 : r'$\left<\epsilon\right>$', 19 : r'$\epsilon_{Min}$', 20 : r'$\epsilon_{Max}$' }

    def iniDefault(self,par):
        self.modelDesc = 'None selected model'
        self.model = None;
        self.start = []
        self.pars  = []
        print('Not implemented model! Available models are: ', self.modelAvail.keys())
    
    # This function sets all variables and parameters requiered for running a given model
    def setModel(self,model,pars=None):
        self.iniC = 0
        # Select the appropriate model function
        # Defining the list of starting functions
        # Defining the parameters
        self.modelAvail.get(model,self.iniDefault)(pars)

    # Shifts a numpy array
    def shiftarr(self,arr, num, fill_value=np.nan):
        result = np.empty_like(arr)
        num = int(num)
        if num > 0:
            result[:num] = fill_value
            result[num:] = arr[:-num]
        elif num < 0:
            result[num:] = fill_value
            result[:num] = arr[-num:]
        else:
            result[:] = arr
        return result        
        
    # Solves the differential equation system
    def getModel(self,x):
        init = [func() for func in self.start]
        xtime = np.linspace(1, len(x), len(x)) 
        #return integrate.odeint(self.model,init,x,args=self.parVals)
        #print("GetModel: ",self.parVals)
        arr = integrate.odeint(self.model,init,xtime,args=self.parVals)
        arrT = arr.T
        for indx in range(len(arrT)):
            arrT[indx] = self.shiftarr(arrT[indx],self.dataStartDay-x[0],0)
        return arrT.T
    
    # Reading the full dataset
    def readData(self,fname):
        self.fullFname = fname
        self.dataMark = fname[:8]
        self.data = None if (fname==None) else pd.read_csv(fname)
        self.data['Date'] =  pd.to_datetime(self.data['Date'])#, format='%d%b%Y:%H:%M:%S.%f')
    
    # This function sets the data to be fitted as well as the intial parameters for the given field
    def getFitData(self, field):
        self.fitDataID = field
        # Selecting the data for the given field
        self.fitData = self.data[["Date","Days","S "+field,"I "+field]].copy()
        # Removing rows with infected equals to zero
        #self.fitData = self.fitData[self.fitData["I "+field] !=0]
        # Getting the initial parameter values
        self.ini = (self.fitData.iloc[0].values)[2:]
        # Setting the days corresponding to this field
        self.fitData.rename(columns={'I '+field:'Infected'}, inplace=True)
        self.days = self.fitData['Date'].copy()
        self.showData = self.fitData[["Date", 'Infected']].copy()
        # Return only the time and infected columns
        self.fitData = self.fitData[["Days", 'Infected']].copy()
        self.realDays = self.fitData['Days'].copy()
        self.dataStartDay = self.fitData['Days'].iloc[0]
        self.fitData['Days'] -= self.dataStartDay - 1
        # Grouping in weeks (7 days)
        tmp = self.fitData['Infected'].values
        week = 7
        #self.fitData = pd.DataFrame() 
        #self.fitData['Infected'] = [np.sum(np.array(tmp[x:x + week])) for x in range(0, len(tmp), week)]
        #self.fitData['Days'] = np.array([ x + 1  for x in range(0, len(self.fitData['Infected'].values))])
        #self.realDays = self.fitData['Days'].copy()
        #self.fitData['Infected'] = np.log(self.fitData['Infected']) 
        return self.fitData
          
    def getInfo(self):
        print("Selected model: ",self.modelDesc)
        print("Full data filename: ", self.fullFname)
        print("Fitting data from: ",self.fitDataID)
        print("Initial values for S and I: ",self.ini)
        print(self.fitData.head())
        print(self.days.head())
        
    # This function plots a single I curve with the corresponding data
    # REVISAR!!!!!!
    def doSinglePlot(self,fitData,pars,maxX=None):
        print('Esta funcion hay que REVISARLA!!!!')
        startV = self.realDays.values[0]
        xtime = self.realDays.values if maxX is None else np.linspace(startV, maxX + startV,maxX + 1)
        self.parVals=tuple(pars)
        Ip = self.getModel(xtime)[:,1]
        try:
            maxI = np.amax(Ip)
            print("Maximun infected individuals: ",maxI)
            if not maxX is None:
                xdate = pd.to_datetime(pd.Series(pd.date_range('20200315', periods=maxX)))
                print("Day of the maximun number of infected individuals: ", xdate[np.where(Ip == maxI)[0][0]])
                self.maxInfo = [maxI,xdate[np.where(Ip == maxI)[0][0]]]
            plt.plot(xtime,Ip,color='red')
        except:
            print("Failed to plot the trend!!!")
        plt.scatter(self.realDays.values,self.fitData['Infected'].values,color='gray')
        plt.title(self.modelDesc+" model for COVID19 ("+self.fitDataID+")")
        plt.xlabel("Days (starting from March 15)")
        plt.ylabel("Infected")
        plt.show()   
        
    def doLikelihood(self):
        COVID19_model = pde.PDEmodel(self.fitData, self.model, self.start, bounds=self.bounds, 
                            param_names=self.pars, nvars=self.nvars, ndims=0, nreplicates=1, obsidx=[1], outfunc=None)
        COVID19_model.likelihood_profiles()
        COVID19_model.plot_profiles()

    def getVals(self,pars):
        start,end,n = pars
        step = (end-start)/(n-1)
        return [start+i*step for i in range(n)]

    def lognorm_params(self,mode, stddev):
        """
        Given the mode and std. dev. of the log-normal distribution, this function
        returns the shape and scale parameters for scipy's parameterization of the
        distribution.
        """
        p = np.poly1d([1, -1, 0, 0, -(stddev/mode)**2])
        r = p.roots
        sol = r[(r.imag == 0) & (r.real > 0)].real
        shape = np.sqrt(np.log(sol))
        scale = mode * sol
        return shape, scale
    
    # Input data refers only to C, delta, eta and epsilon
    # Info corresponds to start,end and n for each of the variables above
    # C is the quarantine percentange of the population
    def getRandPars(self,info,n):
        # beta, tau, q, delta, eta, epsilon
        self.randParVals = []
        step = 1
        for varinf in info:
            if (varinf[4]=='lognorm'):
                mode = varinf[0]
                stddev = varinf[1]
                shift = varinf[2]
                step = varinf[3]
                sigma, scale = self.lognorm_params(mode, stddev)
                sample = lognorm.rvs(sigma, 0, scale, size=n) + shift
            if (varinf[4]=='norm'):
                mu = varinf[0]
                sigma = varinf[1]
                step = varinf[3]
                sample = np.random.normal(mu, sigma, n)
            self.randParVals.append(np.round(sample/step)*step)
        return self.randParVals
        
    def doFit(self,maxX=None,n=None,toPrint=True,data=None):
        if (not(n is None) and not(self.info is None)):
            self.tauOVq = (100-self.randParVals[0][n])/self.randParVals[0][n]
            self.delta = 1/self.randParVals[1][n]
            self.eta = 1/self.randParVals[2][n]
            self.q = self.randParVals[2][n]
            self.epsilon = self.randParVals[3][n]
            self.fE0 = self.randParVals[4][n]
            
        fitData = self.fitData if (data is None) else data
        # Defining the model
        COVID19_model = pde.PDEmodel(fitData, self.model, self.start, bounds=self.bounds, 
                            param_names=self.pars, nvars=self.nvars, ndims=0, nreplicates=1, obsidx=[1], outfunc=None)
        # Do the fitting
        COVID19_model.fit(error='rmsle')
        if (n is None):
            pid = self.fitDataID
        else:
            pid = self.fitDataID+"-"+str(n)
            if ((n%200)==0):
                print("\tBest error ("+pid+"): ", COVID19_model.best_error)
        res = COVID19_model.best_params.values[0]
        self.parVals = tuple(res)
        
        # Returns [id, beta, gamma, reproductive number (beta/gamma), fit error]
        out = [pid]; out.extend(res.tolist()); out.extend([self.R0func(),COVID19_model.best_error])
        # Plotting the best fit
        if (toPrint):
            self.doSinglePlot(fitData,res,maxX)
            cols = self.pars.copy(); cols.extend([r'$R_0$','Fit error'])
            cols = dict([(i,v) for i,v in enumerate(cols)])
            result = pd.DataFrame()
            result[pid] = out[1:]
            display((result.T).rename(columns=cols))
        # If random pars are generated also te input par vals are included in te output
        if (not(n is None) and not(self.info is None)):
            if (self.typeInf==0):
                out.extend([self.tauOVq,self.delta,self.eta,self.epsilon,self.fE0])
            else:
                out.extend([self.tauOVq,self.delta,self.q,self.epsilon,self.fE0])
        return out
    
    # Performs N fits 
    def doStatGRP(self,N,proc=2):
        pool = mp.Pool(proc)#mp.cpu_count()-4)
        res = pool.starmap_async(self.doFit, [(None,n,False) for n in range(N)]).get()
        pool.close()
        return res

    # Runs over a list of ids and saves N fits into a file starting with 'OUT_' and '.cvs' extension
    def doStat(self,N,ids,proc=2,desc='',info=None,typeInf=0):
        result = []
        self.info = info
        for id in ids:
            print("Fitting ",id,"...")
            self.getFitData(id)
            colNames = list(self.colIDs)
            if (not(info is None)):
                self.getRandPars(info,N)
                self.typeInf = typeInf
                if (typeInf==0):
                    colNames.extend(['tauOVq','delta','eta','epsilon','fE0'])
                else:
                    colNames.extend(['tauOVq','delta','q','epsilon','fE0'])
            result.append(pd.DataFrame(self.doStatGRP(N,proc),columns= colNames ))
            result[-1].to_csv(self.modelDesc+'_OUT_'+id+'_'+self.dataMark+'_'+desc+'.csv', index = False)
        self.statData = result

    # Runs over a list of ids and saves N fits into a file starting with 'OUT_' and '.cvs' extension
    def doStatRAND(self,N,ids,proc=2,desc='',info=None):
        result = []
        for id in ids:
            print("Fitting ",id,"...")
            self.getFitData(id)
            result.append(pd.DataFrame(self.doStatGRP(N,proc),columns= self.colIDs ))
            result[-1].to_csv(self.modelDesc+'_OUT_'+id+'_'+self.dataMark+'.csv', index = False)
        self.statData = result
        
    # Returns all the filenames corresponding to a set of fits
    def getStatFiles(self,actdir='./'):
        #print(osfiles.listdir(actdir))
        return [actdir+i for i in osfiles.listdir(actdir) if i.endswith('.csv') and ('OUT_' in i)]# and (self.modelDesc in i)]

    # Reads all the available data for fits of ids
    def readStat(self,actdir='./'):
        self.statData = [ pd.read_csv(fname) for fname in self.getStatFiles(actdir) ]    
    
    # Returns already calculated statistical data for a given field
    def getStatData(self,field):
        for dta in self.statData:
            if(dta.iloc[0,0][0:3]==field):
                self.actStatData = dta
                return
        print(field, " not found!!!")
        
    def getR0column(self):
        statData = self.actStatData.copy()
        R0column = [] 
        for index in range(len(statData.index)): 
            R0column.append(self.R0funcStat((statData.iloc[index].values)[1:]))
        statData[self.R0colLabel] = R0column
        return statData
        
    # Plot with Data
    def getStatPlotWithData(self,field,plotsData):
        plotsData = plotsData[plotsData['Days'] <= self.realDays.iloc[-1]]
        plot = sns.relplot(x="Days", y="Infected", kind="line", data=plotsData)
        plt.scatter(self.realDays.values,self.fitData['Infected'].values,color='gray')
        plt.title(self.modelDesc+" model for COVID19 ("+self.fitDataID+")")
        plt.xlabel("Days (starting from Feb. 28)")
        #plt.ylabel("Infected")
        plt.savefig(self.modelDesc+'_'+field+'_Data.png',dpi=300)
        plt.show()
        return 

        print(self.showData)
        #plotData = pd.DataFrame(pd.to_datetime(self.days),columns=['Date'])
        #plotData['Infected'] = self.fitData.iloc[:, 1].values
        #plotsData = plotsData.loc[plotsData['Date'] <= plotData['Date'].iloc[-1]]
        #actData[actData['UCI']==1]
        plotsData = plotsData[plotsData['Date'] <= self.showData['Date'].iloc[-1]]
        plot = sns.relplot(x="Date", y="Infected", kind="line", data=plotsData)
        plot.set_xticklabels(rotation=30)
        plot.fig.suptitle(self.modelDesc+" model for COVID19 ("+field+")")
        #plt.plot_date(plotData['Date'],plotData['Infected'],color='gray')
        plt.plot_date(self.showData['Date'],self.showData['Infected'],color='gray')
        plt.savefig(self.modelDesc+'_'+field+'_Data.png',dpi=300)
        plt.show()

    
    # Computes all the resulting models from the parameters in actStatData corresponding to field
    def getStatPlotData(self,field,daysToPlot=300):
        result = pd.DataFrame()
        print('Computing: ',field)
        # Setting initial parameters for the field
        self.getFitData(field)
        # Setting the actSatData corresponding to field
        self.getStatData(field)
        # Computing the R0 column
        self.statPlotData = self.getR0column()
        # Sorting the DataFrame by the R0 column and getting the 95% of confidence interval
        self.statPlotData.sort_values(by=[self.R0colLabel], inplace=True, ascending=True)
        self.statPlotData=self.statPlotData.head(-25) # removing the last n rows
        self.statPlotData=self.statPlotData.tail(-25) # removing the first n rows
        result[field] = self.getParsMinMax(self.statPlotData)
        # Setting the x variable in time (for model computing) and date (for the plot)
        xtime = np.linspace(1, daysToPlot, daysToPlot)
        xdate = pd.to_datetime(pd.Series(pd.date_range('20200315', periods=daysToPlot)))
        # Getting the mean parameter values and the meanPlotData
        self.meanStatPars = self.statPlotData.describe().values[1][:len(self.pars)]
        self.parVals = tuple(self.meanStatPars)
        #print(self.parVals,self.eta,self.delta,self.epsilon,self.q)#,self.fracTau)
        meanPlotData = pd.DataFrame(xdate,columns= ['Date'])
        #self.q=1
        #print(self.parVals,self.eta,self.delta,self.epsilon,self.q)#,self.fracTau)
        meanPlotData['Infected'] = self.getModel(xtime)[:,1]
        print("Maximun number of infected individuals (Mean): ",meanPlotData['Infected'].max(), " achieved on ", meanPlotData['Date'].iloc[meanPlotData['Infected'].idxmax()])
        plotsData = []; meanPlot = np.zeros(daysToPlot) 
        for indx in range(len(self.statPlotData.index)):
            #print(self.parVals,self.eta,self.delta,self.epsilon,self.fracTau)
            self.parVals = tuple(self.statPlotData.iloc[indx].values[1:len(self.pars)+1])
            Ivals = self.getModel(xtime)[:,1]
            meanPlot = meanPlot + Ivals
            plotsData.extend(list(np.array([xdate,xtime,Ivals]).T))
        plotsData = pd.DataFrame(plotsData,columns= ['Date','Days','Infected'])
        meanPlot = meanPlot / len(self.statPlotData.index)
        print("Maximun number of infected individuals (Stat): ", np.max(meanPlot), " achieved on ", plotsData['Date'].iloc[np.argmax(meanPlot, axis=0)])
        toFit = pd.DataFrame(list(np.array([xtime,meanPlot]).T),columns= ['Date','Infected'])
        #display(toFit)
        #print(meanPlot)
        self.doFit(maxX=daysToPlot,n=None,toPrint=True,data=toFit)
        toFit['Infected'] = self.getModel(xtime)[:,1]
        plot = sns.relplot(x="Date", y="Infected", kind="line", data=plotsData)
        plot.set_xticklabels(rotation=30)
        plot.fig.suptitle(self.modelDesc+" model for COVID19 ("+field+")")
        plt.savefig(self.modelDesc+'_'+field+'.png',dpi=300)
        #ln, = plt.plot(meanPlotData['Date'],meanPlotData['Infected'],color='red')
        #ln1, = plt.plot(meanPlotData['Date'],toFit['Infected'],color='green')
        #ln2, = plt.plot(meanPlotData['Date'],meanPlot,color='green')
        plt.savefig(self.modelDesc+'_'+field+'_Mean.png',dpi=300)
        plt.show()
        self.getStatPlotWithData(field,plotsData)
        display((result.T).rename(columns=self.DescColID))
    
    def getParsMinMax(self,table):
        data = table.describe();
        R0col = data[self.R0colLabel].values
        result = [R0col[1],R0col[3],R0col[7]]
        mean = data.values[1][:len(self.pars)]
        minV = data.values[3][:len(self.pars)]
        maxV = data.values[7][:len(self.pars)]
        for indx in range(len(self.pars)):
            result.extend([mean[indx],minV[indx],maxV[indx]])
        fitErrcol = data['error'].values
        result.extend([fitErrcol[1],fitErrcol[3],fitErrcol[7]])
        if (not(self.info is None)):
            deltaCol = data['delta'].values
            result.extend([deltaCol[1],deltaCol[3],deltaCol[7]])
            etaCol = data['eta'].values
            result.extend([etaCol[1],etaCol[3],etaCol[7]])
            epsilonCol = data['epsilon'].values
            result.extend([epsilonCol[1],epsilonCol[3],epsilonCol[7]])
        return result
        
    # Computes all the resulting models from the parameters in actStatData corresponding to field
    def getMultStatPlotData(self,fields,daysToPlot=300):
        plotsData = []
        result = pd.DataFrame()
        for field in fields:
            print('Computing: ',field)
            label = [ field for i in range(daysToPlot) ]
            # Setting initial parameters for the field
            self.getFitData(field)
            # Setting the actSatData corresponding to field
            self.getStatData(field)
            # Computing the R0 column
            self.statPlotData = self.getR0column()
            # Sorting the DataFrame by the R0 column and getting the 95% of confidence interval
            self.statPlotData.sort_values(by=[self.R0colLabel], inplace=True, ascending=True)
            self.statPlotData=self.statPlotData.head(-25) # removing the last n rows
            self.statPlotData=self.statPlotData.tail(-25) # removing the first n rows
            result[field] = self.getParsMinMax(self.statPlotData)
            # Setting the x variable in time (for model computing) and date (for the plot)
            xtime = np.linspace(0, daysToPlot-1, daysToPlot)
            xdate = pd.to_datetime(pd.Series(pd.date_range('20200315', periods=daysToPlot)))
            # Getting the mean parameter values and the meanPlotData
            self.meanStatPars = self.statPlotData.describe().values[1][:len(self.pars)]
            self.parVals = tuple(self.meanStatPars)
            for indx in range(len(self.statPlotData.index)):
                self.parVals = tuple(self.statPlotData.iloc[indx].values[1:len(self.pars)+1])
                plotsData.extend(list(np.array([xdate,self.getModel(xtime)[:,1],label]).T))
        plotsData = pd.DataFrame(plotsData,columns= ['Date','Infected','Group'])
        plot = sns.relplot(x="Date", y="Infected", hue="Group", kind="line", data=plotsData)
        plot.set_xticklabels(rotation=30)
        plot.fig.suptitle(self.modelDesc+" model for COVID19")
        plt.savefig(self.modelDesc+'_Comb.png',dpi=300)
        display((result.T).rename(columns=self.DescColID))

    # Computes all the resulting models from the parameters in actStatData corresponding to field
    def getMixedStatPlotData(self,dirs,field,pars,daysToPlot=300):
        plotsData = []
        result = pd.DataFrame()
        meanPlot = np.zeros(daysToPlot) 
        for indx,dirname in enumerate(dirs):
            print('Computing: ',dirname)
            self.readStat(dirname)
            # Setting initial parameters for the field
            self.getFitData(field)
            # Setting the actSatData corresponding to field
            self.getStatData(field)
            # Computing the R0 column
            self.statPlotData = self.getR0column()
            # Sorting the DataFrame by the R0 column and getting the 95% of confidence interval
            self.statPlotData.sort_values(by=[self.R0colLabel], inplace=True, ascending=True)
            self.statPlotData=self.statPlotData.head(-25*len(dirs)) # removing the last n rows
            self.statPlotData=self.statPlotData.tail(-25*len(dirs)) # removing the first n rows
            # Setting the x variable in time (for model computing) and date (for the plot)
            xtime = np.linspace(0, daysToPlot-1, daysToPlot)
            xdate = pd.to_datetime(pd.Series(pd.date_range('20200315', periods=daysToPlot)))
            # Getting the mean parameter values and the meanPlotData
            #self.meanStatPars = self.statPlotData.describe().values[1][:len(self.pars)]
            #self.parVals = tuple(self.meanStatPars)
            self.eta = pars[indx][0]
            self.fracTau = pars[indx][1]
            for indx in range(len(self.statPlotData.index)):
                self.parVals = tuple(self.statPlotData.iloc[indx].values[1:len(self.pars)+1])
                Ivals = self.getModel(xtime)[:,1]
                plotsData.extend(list(np.array([xdate,Ivals]).T))
                meanPlot = meanPlot + Ivals
        plotsData = pd.DataFrame(plotsData,columns= ['Date','Infected'])
        plot = sns.relplot(x="Date", y="Infected", kind="line", data=plotsData)
        meanPlot = meanPlot / (len(self.statPlotData.index)*len(dirs))
        print("Maximun number of infected individuals (Stat): ", np.max(meanPlot), " achieved on ", plotsData['Date'].iloc[np.argmax(meanPlot, axis=0)])
        toFit = pd.DataFrame(list(np.array([xtime,meanPlot]).T),columns= ['Date','Infected'])
        #display(toFit)
        #print(meanPlot)
        self.doFit(maxX=daysToPlot,n=None,toPrint=True,data=toFit)
        toFit['Infected'] = self.getModel(xtime)[:,1]
        ln, = plt.plot(meanPlotData['Date'],meanPlotData['Infected'],color='red')
        ln1, = plt.plot(meanPlotData['Date'],toFit['Infected'],color='green')
        plot.set_xticklabels(rotation=30)
        plot.fig.suptitle(self.modelDesc+" model for COVID19")
        plt.savefig(self.modelDesc+'_All.png',dpi=300)
        #display((result.T).rename(columns=self.DescColID))
            
            
        return 
        for field in fields:
            print('Computing: ',field)
            label = [ field for i in range(daysToPlot) ]
            # Setting initial parameters for the field
            self.getFitData(field)
            # Setting the actSatData corresponding to field
            self.getStatData(field)
            # Computing the R0 column
            self.statPlotData = self.getR0column()
            # Sorting the DataFrame by the R0 column and getting the 95% of confidence interval
            self.statPlotData.sort_values(by=[self.R0colLabel], inplace=True, ascending=True)
            self.statPlotData=self.statPlotData.head(-25) # removing the last n rows
            self.statPlotData=self.statPlotData.tail(-25) # removing the first n rows
            result[field] = self.getParsMinMax(self.statPlotData)
            # Setting the x variable in time (for model computing) and date (for the plot)
            xtime = np.linspace(0, daysToPlot-1, daysToPlot)
            xdate = pd.to_datetime(pd.Series(pd.date_range('20200315', periods=daysToPlot)))
            # Getting the mean parameter values and the meanPlotData
            self.meanStatPars = self.statPlotData.describe().values[1][:len(self.pars)]
            self.parVals = tuple(self.meanStatPars)
            for indx in range(len(self.statPlotData.index)):
                self.parVals = tuple(self.statPlotData.iloc[indx].values[1:len(self.pars)+1])
                plotsData.extend(list(np.array([xdate,self.getModel(xtime)[:,1],label]).T))
        plotsData = pd.DataFrame(plotsData,columns= ['Date','Infected','Group'])
        plot = sns.relplot(x="Date", y="Infected", hue="Group", kind="line", data=plotsData)
        plot.set_xticklabels(rotation=30)
        plot.fig.suptitle(self.modelDesc+" model for COVID19")
        plt.savefig(self.modelDesc+'_Comb.png',dpi=300)
        display((result.T).rename(columns=self.DescColID))

    # Computes all the resulting models from the parameters in actStatData corresponding to field
    def getStatPlotDataRand(self,field,daysToPlot=300,info=None):
        self.info = info
        result = pd.DataFrame()
        print('Computing: ',field)
        # Setting initial parameters for the field
        self.getFitData(field)
        # Setting the actSatData corresponding to field
        self.getStatData(field)
        # Computing the R0 column
        # self.statPlotData = self.getR0column()
        self.statPlotData = self.actStatData.copy()
        # Sorting the DataFrame by the R0 column and getting the 95% of confidence interval
        self.statPlotData.sort_values(by=[self.R0colLabel], inplace=True, ascending=True)
        self.statPlotData=self.statPlotData.head(-25) # removing the last n rows
        self.statPlotData=self.statPlotData.tail(-25) # removing the first n rows
        print(self.statPlotData.describe())
        result[field] = self.getParsMinMax(self.statPlotData)
        # Setting the x variable in time (for model computing) and date (for the plot)
        xtime = np.linspace(0, daysToPlot-1, daysToPlot)
        xdate = pd.to_datetime(pd.Series(pd.date_range('20200315', periods=daysToPlot)))
        # Getting the mean parameter values and the meanPlotData
        self.meanStatPars = self.statPlotData.describe().values[1][:len(self.pars)]
        self.parVals = tuple(self.meanStatPars)
        #print(self.parVals,self.eta,self.delta,self.epsilon,self.fracTau)
        meanPlotData = pd.DataFrame(xdate,columns= ['Date'])
        meanPlotData['Infected'] = self.getModel(xtime)[:,1]
        print("Maximun number of infected individuals (Mean): ",meanPlotData['Infected'].max(), " achieved on ", meanPlotData['Date'].iloc[meanPlotData['Infected'].idxmax()])
        plotsData = []; meanPlot = np.zeros(daysToPlot) 
        for indx in range(len(self.statPlotData.index)):
            #print(self.parVals,self.eta,self.delta,self.epsilon,self.fracTau)
            self.parVals = tuple(self.statPlotData.iloc[indx].values[1:len(self.pars)+1])
            self.tauOVq = self.statPlotData.iloc[indx].values[5]
            self.delta = self.statPlotData.iloc[indx].values[6]
            self.eta = self.statPlotData.iloc[indx].values[7]
            self.epsilon = self.statPlotData.iloc[indx].values[8]
            Ivals = self.getModel(xtime)[:,1]
            meanPlot = meanPlot + Ivals
            plotsData.extend(list(np.array([xdate,xtime,Ivals]).T))
        plotsData = pd.DataFrame(plotsData,columns= ['Date','Days','Infected'])
        meanPlot = meanPlot / len(self.statPlotData.index)
        print("Maximun number of infected individuals (Stat): ", np.max(meanPlot), " achieved on ", plotsData['Date'].iloc[np.argmax(meanPlot, axis=0)])
        toFit = pd.DataFrame(list(np.array([xtime,meanPlot]).T),columns= ['Date','Infected'])
        fitted = pd.DataFrame(list(np.array([xtime,meanPlot]).T),columns= ['Date','Infected'])
        #display(toFit)
        #print(meanPlot)
        #self.setModel('SEIRrand')
        #self.tauInt = False
        #self.doFit(maxX=None,n=None,toPrint=True,data=toFit)
        #fitted['Infected'] = self.getModel(xtime)[:,1]
        plot = sns.relplot(x="Date", y="Infected", kind="line", data=plotsData)
        plot.set_xticklabels(rotation=30)
        plot.fig.suptitle(self.modelDesc+" model for COVID19 ("+field+")")
        plt.savefig(self.modelDesc+'_'+field+'.png',dpi=300)
        ln, = plt.plot(meanPlotData['Date'],meanPlotData['Infected'],color='red')
        ln1, = plt.plot(meanPlotData['Date'],toFit['Infected'],color='green')
        #ln2, = plt.plot(meanPlotData['Date'],fitted['Infected'],color='black')
        plt.savefig(self.modelDesc+'_'+field+'_Mean.png',dpi=300)
        plt.show()
        self.getStatPlotWithData(field,plotsData)
        display((result.T).rename(columns=self.DescColID))
    
        